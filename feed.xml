<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://g14a.github.io</id> <title>g14a</title> <subtitle>Thoughts and Knowledge.</subtitle> <updated>2024-09-11T16:43:20+05:30</updated> <author> <name>g14a</name> <uri>https://g14a.github.io</uri> </author> <link href="/feed.xml" rel="self" type="application/atom+xml" /> <link href="https://g14a.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 g14a </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry> <title>LRU Cache Using Go in under 100 lines!</title> <link href="https://g14a.github.io/posts/lru-cache/" rel="alternate" type="text/html" title="LRU Cache Using Go in under 100 lines!" /> <published>2022-02-05T09:03:00+05:30</published> <updated>2022-02-05T09:03:00+05:30</updated> <id>https://g14a.github.io/posts/lru-cache/</id> <content src="https://g14a.github.io/posts/lru-cache/" /> <author> <name>g14a</name> </author> <category term="tutorials" /> <summary> Vague introduction to LRU Caches Hello fellow internet user! I assume you know what caches are and how they work. Today let’s see how we can design an LRU cache using our favourite language Go with as little code as possible. LRU when expanded is Least Recently Used. So it basically means whichever entry is the least used after we put it, will be kicked out and replaced by a new entry. This ... </summary> </entry> <entry> <title>Channels and Deadlocks in Go with a File crawler</title> <link href="https://g14a.github.io/posts/channels-and-deadlocks/" rel="alternate" type="text/html" title="Channels and Deadlocks in Go with a File crawler" /> <published>2021-11-27T14:30:00+05:30</published> <updated>2024-09-11T16:36:56+05:30</updated> <id>https://g14a.github.io/posts/channels-and-deadlocks/</id> <content src="https://g14a.github.io/posts/channels-and-deadlocks/" /> <author> <name>g14a</name> </author> <category term="tutorials" /> <summary> Welcome back! We’ve seen in the earlier sections that channels can be used to improve and control concurrency in Golang. But let’s look at it again with a fresh mind. Let’s unlearn things and re-learn them again. Assumptions Going forward I assume that you have basic knowledge of Go syntax and how to write Go programs/build them. Even though we’re re-learning things I assume that you h... </summary> </entry> <entry> <title>Testing Cobra Subcommands</title> <link href="https://g14a.github.io/posts/Testing-Cobra-Subcommands/" rel="alternate" type="text/html" title="Testing Cobra Subcommands" /> <published>2021-06-14T22:30:00+05:30</published> <updated>2024-09-11T16:36:56+05:30</updated> <id>https://g14a.github.io/posts/Testing-Cobra-Subcommands/</id> <content src="https://g14a.github.io/posts/Testing-Cobra-Subcommands/" /> <author> <name>g14a</name> </author> <category term="article" /> <summary> Just an Intro Go has been around for more than 10 years now. Recently more than a dozen tools and frameworks have come out making us create CLI apps easily than ever. Out of those countless tools, we know that spf13/cobra has stood out. It is completely tested and is readily usable. And when we’re designing CLI apps, we’re usually refactoring our whole application to make it ready for testing ... </summary> </entry> <entry> <title>Using Go Channels - Part 4 - Image Processing with Channels - Part 2</title> <link href="https://g14a.github.io/posts/using-Go-Channels-p5/" rel="alternate" type="text/html" title="Using Go Channels - Part 4 - Image Processing with Channels - Part 2" /> <published>2021-04-16T14:30:00+05:30</published> <updated>2024-09-11T16:36:56+05:30</updated> <id>https://g14a.github.io/posts/using-Go-Channels-p5/</id> <content src="https://g14a.github.io/posts/using-Go-Channels-p5/" /> <author> <name>g14a</name> </author> <category term="tutorials" /> <summary> A Tiny Recap In the earlier section Part - 4, we have seen the serial and parallel versions of our image processing program. Now let us see if we can make our parallel version even better. Hope you're as excited as Kevin! Worker Pool If we take a look at our previous main function, we see that we read the image and then pass it to the Save function. So until we read the image an... </summary> </entry> <entry> <title>Using Go Channels - Part 4 - Image Processing with Channels</title> <link href="https://g14a.github.io/posts/using-Go-Channels-p4/" rel="alternate" type="text/html" title="Using Go Channels - Part 4 - Image Processing with Channels" /> <published>2021-04-15T18:30:00+05:30</published> <updated>2024-09-11T16:36:56+05:30</updated> <id>https://g14a.github.io/posts/using-Go-Channels-p4/</id> <content src="https://g14a.github.io/posts/using-Go-Channels-p4/" /> <author> <name>g14a</name> </author> <category term="tutorials" /> <summary> A Tiny Recap In the earlier section Part - 3 , we have learnt: What read and write specific channels are How we use select in the context of goroutines Finally, how we apply timeouts in select In this section, we apply whatever we have learnt about channels until now and perform a real world task. Exercise In this exercise we do a little image manipulation using the following Go li... </summary> </entry> </feed>
